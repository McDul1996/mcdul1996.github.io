<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on McDul的博客</title>
    <link>http://mcdul1996.github.io/posts/</link>
    <description>Recent content in Posts on McDul的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 07 Jun 2020 07:55:48 +0800</lastBuildDate>
    
	<atom:link href="http://mcdul1996.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>23-java web: web前后端架构分析实战</title>
      <link>http://mcdul1996.github.io/posts/%E7%AC%AC23%E8%8A%82%E8%AF%BE%E7%9A%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 07 Jun 2020 07:55:48 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E7%AC%AC23%E8%8A%82%E8%AF%BE%E7%9A%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</guid>
      <description>Web前后端基础架构原理 计算机⽹络是如何⼯作的(数据是如何发送和接收的)  在打开⽹⻚的时候发⽣了什么    计算机网络：
 世界上很多台主机彼此之间用网络连接起来，每个主机都有个IP地址    IP地址(Internet Protocol Address:网络协议)：
 在IPV4的世界里是32位，4个Byte(无符号，所以每个Byte最大不超过255)，用点连接起来的IP地址 每个地址都可以准确定位到一台主机 IPv6可以为地球上的每一粒沙子提供一个地址，可以解决IPV4带来的IP地址短缺问题    域名与DNS(域名解析服务器)
  在网页上输入豆瓣网址的时候，按下回车 如果计算机不知道淘宝的主机在哪，它就会向DNS请求查询douban.com,DNS会返回一个地址154.8.131.172，按照这个地址，你就能够去跟豆瓣的主机通信了
  如果本地hosts恰好保存了从douban.com-&amp;gt;154.8.131.172的映射 我们就不需要查找DNS了，节省时间
    端⼝：
  HTTPS协议的默认端⼝是443，HTTP协议的默认端⼝是80
  端口指定了你通信的这个主机上的一个归属地
    TCP协议(Transmission Control Protocol：传输控制协议)
 TCP是基于流的协议,在⽹络上传输的只是字节流，这点非常关键！请记住！ TCP是一条双向的数据高速公路：向你想要访问的服务器所指定的端口开辟了一条双向双车道的一个数据高速公路 定义了字节流在网络上如何发送和接收    浏览器是如何⼯作的(数据是如何被浏览器处理的)   HTTP协议(HyperText Transfer Protocol:超文本传输协议)
 通过浏览器给豆瓣发送一个HTTP请求 请求报文的组成内容:  请求行: 请求方法 + URL + HTTP/版本号 请求头 空行 请求体   豆瓣服务器处理浏览器请求，将处理结果返回给浏览器(响应)：  响应头(Response Headers):HTTP/版本号 + 返回码 + 返回码描述  HTTP/1.</description>
    </item>
    
    <item>
      <title>关于我在Collection体系中学到的知识</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8collection%E4%BD%93%E7%B3%BB%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 06 Jun 2020 16:15:12 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8collection%E4%BD%93%E7%B3%BB%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/</guid>
      <description>Collection体系的常用类及其背后的数据结构  List    ArrayList： 背后是一个动态数组，有序插入元素，可以根据下标取得对应元素，检索元素为线性查找，效率较低。当容量不足时会自动扩容，每次新建一个新的List，大小为原来的1.5倍，再将所有元素拷贝到新的List中去。
  LinkedList： 背后是一个链表结构，有序插入元素，可以根据下标取得对应元素， 检索时从头部或者尾部不断向下标靠拢，所以头部和尾部的查找效率高，中间低。
   Set   HashSet： 计算出元素的哈希值，哈希值相同的元素放在同一个哈希桶里，每个哈希桶里维护一个链表。插入的元素是无序的且不允许出现重复元素，查找效率高。但当发生哈希碰撞时，整个结构退化为链表会导致性能急剧下降。 LinkedHashSet： 不同于HashSet，前面的数据结构为链表，所以是有序的，其他几乎一样。 TreeSet： 前面的数据结构为二叉树，可以对插入的元素进行排序。检索快，时间复杂度降为对数级。   Map   HashMap： 实质上和HashSet一样，不过可以存储键（Key）到值（Value）的映射。JDK1.8之后当链表节点大于7时会裂变为红黑树。 TreeMap： 可以排序的HashMap。  ArrayList源码分析    ArrayList是最常用的一种集合类型  public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable 表示ArrayList继承自AbstractList,实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。 说明它具备以下特点：
 浅拷贝 序列化   常量 private static final int DEFAULT_CAPACITY = 10;  DEFAULT_CAPACITY 表示默认的容量是10个元素   成员变量 transient Object[] elementData; private int size;  elementData为实际存储元素的数组，这里可以看到ArrayList的底层实际是一个数组。因此它具有数组的特点，随机读写快，插入删除慢。 transient关键字说明底层数组不能被序列化。   构造函数 public ArrayList() { this.</description>
    </item>
    
    <item>
      <title>游戏题材</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%A5%E5%90%8E%E6%83%B3%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A2%98%E6%9D%90.md/%E6%B8%B8%E6%88%8F%E9%A2%98%E6%9D%90/</link>
      <pubDate>Tue, 02 Jun 2020 17:24:19 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%A5%E5%90%8E%E6%83%B3%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A2%98%E6%9D%90.md/%E6%B8%B8%E6%88%8F%E9%A2%98%E6%9D%90/</guid>
      <description>人生有好多细节,决定了你的成长速度</description>
    </item>
    
    <item>
      <title>关于我对maven和java包管理的理解</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9maven%E5%92%8Cjava%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sat, 30 May 2020 11:45:07 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9maven%E5%92%8Cjava%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>java的包管理 1. 什么是包  就是一个包含许多类的一个压缩包 这个包的作用是： 当JVM要找一个类的时候，它就会从classpath(类路径)里挨个一个个包里寻找这个类  2. 什么是包管理  包管理的本质就是告诉JVM如何找到所需要的第三方类库 并且可以解决其中的冲突问题(classpath里的某些包都含有同名不同版本的类，由于基本规则选择的那个优先的类里面的代码并不是你想要的，可能还存在BUG)  3. Maven是什么  Maven是划时代的包管理工具(必须强调Maven远远不止是包管理工具) Convention over configuration(约定优于配置) Maven有两个仓库 Maven的中央仓库：在远端的服务器上 包含了世界上所有的包(按照一定的约定存储包) Maven的本地仓库：默认位于~/.m2 你不可能每次编译的时候都把世界上所有的包下载下来，你可能想要在断网的时候进行编译 当你需要用包的时候，maven会帮你自动的从中央仓库下载，下载的第三方包放在这里进行缓存  4. Maven的包  按照约定为所有的包编号，⽅便检索 groupId/artifactId/version 扩展：语义化版本 SNAPSHOT快照版本： 因为maven有一个约定：当你这个包发布的时候，不允许你再去修改它，但是你在开发过程中需要频繁的修改它 传递性依赖：虽然你只下载了一个包，但maven会根据pom将这个包的完整的依赖树都下载下来 传递性依赖的⾃动管理 原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决原则：最近的胜出(但是很可能这个胜出的包里面的类的代码并不是你想要的，这个时候我们就需要根据自己的需要利用Maven使自己想要的包胜出) 方法1：既然是谁离得近谁赢，那就直接在我的项目里直接依赖我想要的版本的jar包 方法2：直接使用 排除那个胜出的版本的包  </description>
    </item>
    
    <item>
      <title>如何使用 Hugo 搭建个人博客</title>
      <link>http://mcdul1996.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Thu, 28 May 2020 16:03:50 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>1.下载 Hugo
进入Hugo下载 在 Assets 中下载合适的版本， 例如：hugo_0.58.3_Windows-64bit.zip （找各自系统对应的版本下载） 解压到自定义文件夹（我的是解压到 D:\Software\hugo） 2.配置环境变量
我的电脑—-&amp;gt;属性—-&amp;gt;高级系统设置—-&amp;gt;环境变量—-&amp;gt;系统变量—-&amp;gt; Path—-&amp;gt;新增 D:\Hugo 路径（根据 hugo.exe 的位置自行更换路径） 重启终端，运行hugo version 查看版本 3.利用 hugo 生成自己的博客 site
推荐找个安全的目录打开命令行,我的目录是 D:\Software\McDul 复制执行下条命令: hugo new site [username].github.io-creator 会生成一个文件夹[username].github.io-creator 接着进入这个文件目录： cd [username].github.io-creator 创建 git 本地仓库： git init 下载 Ananke 博客主题： git submodule add https://github.com/budparr/gohugo-theme-ananke.gitthemes/ananke  在 config.toml 文件中将主题改成 Ananke： echo &amp;#39;theme=Ananke&amp;#39; &amp;gt;&amp;gt; config.toml 用 hugo 搭建了自己的博客已完成 4.开始建立第一篇博客
新建文章： hugo new posts/第二篇博客.md 运行 code posts/第二篇博客.md 对文件进行编辑， 注意不要把文件原本的内容给删了，直接在后面另起一行写新内容， 修改好之后将 draft 后的 true 改成 false 表示已经不是草稿模式， 保存。 5.</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://mcdul1996.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Tue, 26 May 2020 16:38:47 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>大家好 我的博客开通了，希望我能写出好文章给大家看。</description>
    </item>
    
  </channel>
</rss>