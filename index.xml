<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>McDul的博客</title>
    <link>http://mcdul1996.github.io/</link>
    <description>Recent content on McDul的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Wed, 05 Aug 2020 20:40:22 +0800</lastBuildDate>
    
	<atom:link href="http://mcdul1996.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTML常用标签</title>
      <link>http://mcdul1996.github.io/posts/html/</link>
      <pubDate>Wed, 05 Aug 2020 20:40:22 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/html/</guid>
      <description>HTML 常用标签 a 标签的用法 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等
table 标签 用来写表格的
img 标签 发出 GET 请求，展示一张图片</description>
    </item>
    
    <item>
      <title>MyBatis从⼊⻔到精通</title>
      <link>http://mcdul1996.github.io/posts/39/</link>
      <pubDate>Wed, 29 Jul 2020 11:19:39 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/39/</guid>
      <description>MyBatis从⼊⻔到精通 MyBatis是什么  ⼀个ORM框架 国内基本上都在⽤ 简单、⽅便  Object Relationship Mapping  对象关系映射  ⾃动完成对象到数据库的映射   Association  ⾃动装配对象    从零开始MyBatis  看官⽅⽂档就够了 ⾸先配置⽇志框架，可以极⼤地提⾼排查问题的效率 然后配置数据源 Mapper：接⼝由MyBatis动态代理  优点：⽅便 缺点：SQL复杂的时候不够⽅便   Mapper：⽤XML编写复杂SQL  优点：可以⽅便地使⽤MyBatis的强⼤功能 缺点：SQL和代码分离    有关Mapper的⼀切  parameterType  参数的#{}和${} 参数是按照Java Bean约定读取的:getter/setter   resultType  typeAlias 写参数是按照Java Bean约定的:getter/setter   Association  动态SQL——MyBatis的灵魂  if choose foreach script  MyBatis的缓存  缓存是如何⼯作的？ MyBatis缓存源代码深⼊解读  Decorator模式    </description>
    </item>
    
    <item>
      <title>HashMap源码解读</title>
      <link>http://mcdul1996.github.io/posts/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sat, 18 Jul 2020 16:47:04 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/hashmap%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
      <description>HashMap源码解读  为什么数组的长度一定要是2的N次方  只有这样，我们在对它进行-1操作的时候才能拿到全是1的值，可以非常快速的按照位运算的方式拿到数组的下标，并且桶的分布还是均匀的    java8HashMap的改进  数组+链表/红黑树 扩容时插入顺序的改进 函数方法  forEach compute系列   Mapde的新API  merge replace    </description>
    </item>
    
    <item>
      <title>算法与数据结构</title>
      <link>http://mcdul1996.github.io/posts/31/</link>
      <pubDate>Fri, 10 Jul 2020 10:53:33 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/31/</guid>
      <description>程序=算法+数据结构  算法：规定程序如何运行 数据结构：规定里面的数据如何存储  为什么我们需要算法和数据结构？  计算机世界的基⽯，是程序员的内功，所有语言通用 对代码效率的提升是本质的 ⾯试需要……  算法的复杂度  时间复杂度  O(1) - 哈希桶/数组随机寻址 （常数） O(n) - 遍历 （线性） O(log(n)) - ⼆分查找，⼆叉树 （对数） O(n*log(n)) - 基于⽐较的排序算法的下界 O(n^2) - 冒泡排序 （平⽅）   时间复杂度的计算是忽略常数的  即 O(n)=O(2n)   时间复杂度的计算中，⾼阶复杂度会吞并低阶复杂度  O(n^2)+O(n)=O(n^2)    基本数据结构 - 数组  随机寻址  常数时间   插⼊/删除  线性时间   查找  ⽆序：线性时间 有序：对数时间（⼆分查找）   【要求】⼿写⼆分查找  基本数据结构 - 链表  寻址  线性时间   插⼊/删除  常数时间   查找  线性时间   【要求】⼿写  翻转链表 判断链表是否成环    基本数据结构 - 栈 Stack  FILO （First In Last Out） 应⽤：⽅法栈 【要求】⼿写⼀个栈的实现  基本数据结构 - 队列 Queue  FIFO （First In First Out） 应⽤：线程池 【要求】⼿写⼀个队列的实现  基本数据结构 - 哈希表  查找/插⼊/删除操作都是 O(1) 哈希算法与碰撞 哈希桶的内部实现  基本数据结构 - ⼆叉树  ⼆叉树有两个孩⼦  相应的，多叉树有多个孩⼦   【要求】⼿写：  ⼆叉树的深度优先遍历 ⼆叉树的⼴度优先遍历    基本数据结构 - 搜索⼆叉树  ⼀棵经过精⼼设计的⼆叉树 可以将搜索效率降低到对数时间 致命缺点：可能会退化成链表  红⿊树    排序算法 - 综述  最基础的算法 基于⽐较的排序算法的复杂度下界是 O(nlog(n)) 排序的稳定性 Java 默认⽤什么排序算法？  排序算法 - 冒泡排序  最直观，最容易理解的排序算法 想象⼀下你是体育委员，要对班级同学排序 效率低，始终是 O(n^2) 【要求】能⼿写  排序算法 - 快速排序  每次将等待排序的数据划分成两部分 递归进⾏ 直到所有数据有序  排序算法 - 归并排序  分⽽治之  将⼀个⼤问题分解成⼩问题 解决⼩问题 递归地解决⼤问题   空间复杂度 O(n)  Q &amp;amp; A * * * * *</description>
    </item>
    
    <item>
      <title>多线程与并发原理</title>
      <link>http://mcdul1996.github.io/posts/28/</link>
      <pubDate>Mon, 22 Jun 2020 12:53:10 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/28/</guid>
      <description>多线程与并发原理 为什么需要多线程  CPU：你们都慢！死！了！（CPU实在是太快了，以至于想要尽可能的利用CPU的速度，不能光等待，可以做点其他事） 现代CPU都是多核的,多线程可以尽可能的实现出多核的价值  理论上具有天然并发的能力(1GHZ: 1G * cycle(时间周期)/秒 = 1*cycle/ns(纳秒)) 堆核心：又要快又可以避免发热量太大(Q=i²Rt)   Java的执⾏模型是同步/阻塞(block)的1个 默认情况下只有⼀个线程  处理问题⾮常⾃然 但是具有严重的性能问题    我能不能多请⼏个⼈来⼲活？  开启⼀个新的线程  Thread  Java中只有这么⼀种东⻄代表线程 start⽅法才能并发执⾏！ 每多开⼀个线程，就多⼀个执⾏流 ⽅法栈(局部变量)是线程私有的 静态变量/类变量是被所有线程共享的(伴随着的问题是几乎所有的坑都来自这里)      线程难的本质原因是 你要看着同⼀份代码， 想象不同的⼈在疯狂地以乱序执⾏它  难就难在共享变量的处理  演示多线程带来的性能提升  对于IO密集型应⽤极其有⽤  ⽹络IO（通常包括数据库）：处理完请求，发送给用户要经过网络IO，它很慢，等它的时间不如去做点其他事情（处理其他用户的请求） ⽂件IO   对于CPU密集型应⽤稍有折扣：不适合使用多线程，一个就基本够CPU受的了 性能提升的上限在哪⾥？  单核CPU 100% 多核CPU N*100%    昂贵的线程  能不能使⽤线程达到⽆穷⽆尽的性能提升?  ⼗个⼥⼈⼀个⽉能⽣⼀个孩⼦么？   线程的昂贵性在于  第⼀，CPU切换上下⽂很慢 第⼆，线程需要占⽤内存等系统资源   如果你的应⽤⼀天才⼏个⽤户  new Thread().</description>
    </item>
    
    <item>
      <title>数据库原理</title>
      <link>http://mcdul1996.github.io/posts/27/</link>
      <pubDate>Tue, 16 Jun 2020 17:00:36 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/27/</guid>
      <description>数据库原理 Java过时了么？  当之⽆愧的世界第⼀编程语⾔ 海量的需求 未来会过时么？  如果你想要把数据持久化，怎么办？  2B⻘年：拿笔抄！ 普通⻘年：写⽂件！  CSV=Comma Separated Value ⽂件 即逗号分隔符⽂件 ⽼板说，请把id⼤于100的数据筛选出来。 ⽼板说，请把数据和⽤户的信息都筛选出来 ⽼板说，能不能把这些数据和评论⼀起显示出来？   ⽂艺⻘年：写数据库！  普通⻘年的写⽂件  CSV⽂件 读写CSV⽂件  但是业务需求千变万化 所以&amp;mdash;数据库横空出世  数据库提供结构化数据的持久化存储 索引保证数据查询的速度 事务的原⼦性保证数据不丢失  ATM1: 把钱给你 啪唧，ATM断电了。 ATM2：在你的账户上扣钱 事务的原 子性(要么一件事情都不发生，要么都发生)    Docker⽅式安装⼀切数据库  百分百兼容 百分百⽆残留 百分百统⼀、⽅便 MySQL/PostgreSQL为例 H2数据库不需要安装 现在我们启动的数据库的数据是不持久化的  除⾮在启动容器的时候使⽤-v参数    数据库实战  Schema：设计⾃⼰的第⼀个数据库  数据库的类型与SQL语句  整数类型，例如int/bigint 字符串类型，例如(可变的字符串集)varchar(100)/TEXT 时间类型，例如timestamp   ⾏与列 数据的外键   JDBC简介：Java Database Connection  本质就是：你给我⼀个连接字符串，我就能读取你的数据库的信息   H2简介 使⽤JDBC存取数据  DDL-SQL  create table 建表语句 drop table 删表语句 alter table 修改表  基本SQL  insert into - 增 delete from - 删 update - 改 select - 查 重要的要记住的知识：  SQL语句不区分⼤⼩写 命名⻛格是下划线分割两个单词 数据库中的字符串是单引号 数据库的注释是&amp;ndash; 分号分割多个SQL语句    SELECT魔法  Select * Select count(*) count(1) Select max/min/avg Select limit 分⻚ select order by 排序 Select is null/is not null Select where id in ()  数据库的表设计原则  每个实体⼀张表（⽤户/商品）  每个实体都有⼀个主键ID 按照业务需要建索引   每个关系⽤⼀张表联系  关系型数据库    使⽤JDBC访问数据库  Java Database Connection  连接串 ⽤户名 密码   Statement PrepareStatement - 防SQL注⼊的 ResultSet  SQL注⼊与防范  什么是SQL注⼊  SQL注⼊是因为SQL没有验证传⼊的参数 导致攻击者可以通过精⼼设计的参数使得拼装出的SQL达 到他的⽬的   JDBC如何进⾏防范？  JOIN  什么是JOIN以及为什么需要JOIN INNER JOIN LEFT JOIN RIGHT JOIN  </description>
    </item>
    
    <item>
      <title>异常体系</title>
      <link>http://mcdul1996.github.io/posts/26/</link>
      <pubDate>Sun, 14 Jun 2020 16:37:11 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/26/</guid>
      <description>异常体系 try/catch/finally  try:如果没有try，异常将击穿所有的栈帧  与下面任何一个配合使用,或者使用 try(&amp;ldquo;设置需要清理的东西) {} (只有实现了AutoCloseable接口的东西才可以用这种方法清理) catch可以将⼀个异常抓住  处理异常 在日志里打印异常 返回对应的对异常的处理   finally只执⾏清理⼯作，千万不要包含return;   JDK7+：try-with-resources(java7的语法塘，让代码简洁一点，仅此而已，可以根据Idea提示)  throw/throws  throw抛出⼀个异常，终止当前流程 throws只是⼀个声明，可有可无，有后面的引用这个方法的人来讲很烦  Java的异常体系  Throwable - 可以被抛出的东⻄（有毒）  Exception - checked execption（受检异常，有毒，代表 ⼀种预料之中的异常，IOException） *必须被显示声明，或者处理 RuntimeException - unchecked execption（运⾏时异常，⽆毒，代表⼀种预料 之外的异常，因此不需要声明） Error （错误，⽆毒）   catch的级联与合并  从小到大抓取异常    Throwable  栈轨迹 Stacktrace （排查问题最重要的信息，没有之⼀）  讲究方法  将一个checked execption包裹成了一个unchecked execption     异常链(Caused by)  知道这个异常的根本在哪里产生，被包裹的样子    异常的抛出原则  能⽤if/else处理的，不要使⽤try/catch  你可能会抓住一个不是你想要的异常：比如try里面方法调用后产生的异常 异常的创建非常的昂贵  因为异常的创建会把栈轨迹给填满，这样你才能拿到信息(异常链) 与if/else的时间周期差距可能是几千，几万倍！！     尽早抛出异常  如果不能处理，必须立刻抛出，不然可能会让这个问题变得更加复杂   异常要准确、带有详细信息  准确的表达这个异常正在发生的事情 尽可能多的带有详细的信息 一个写错的异常比没有异常更可怕，误导人   抛出异常也⽐悄悄地执⾏错误的逻辑强的多  异常的处理原则  本⽅法是否有责任处理这个异常？  不要处理不归⾃⼰管的异常   本⽅法是否有能⼒处理这个异常？  有能力处理：假如你是日志模块，丢了一个异常，你将这个异常抓住并且写到日志里 无能力处理：调用连接数据库，数据库抛了一个异常，一般是没有能力处理的 如果⾃⼰⽆法处理，就抛出 千万不能继续返回错误的结果   如⾮万分必要，不要忽略异常(抓住后吞掉)  除非在特定情况下：你非常确定与你参数有关的异常是绝对不会触发的，比如使用UTF-8去编码，肯定世界上所有的计算机平台都支持，绝对不会因为不支持触发这个异常，所以你只好把他吞掉    try { URLDecoder.</description>
    </item>
    
    <item>
      <title>File与IO</title>
      <link>http://mcdul1996.github.io/posts/25/</link>
      <pubDate>Wed, 10 Jun 2020 17:50:29 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/25/</guid>
      <description>java的IO CPU：这个世界慢！死！了！ ⼀切⽂件的本质  ⼀段字节流： ⽂本⽂件（txt/代码/HTML等） ⼆进制⽂件 每个程序负责解释⽂件中的字节流  InputStream/OutputStream  抽象的输⼊/输出操作，⽆论是：  ⽂件写⼊字节流【实战】 从⽹络读取字节流【实战】 从其他什么破烂玩意读取字节流【实战】   谨记：  如果你不是对⽂件系统⼗分熟悉的话，请永远使⽤绝对路 径！！！！    Java中的File  不要误会！不要误会！不要误会！  File并不代表⼀个“⽂件”，它只代表⼀个“路径” 抽象的“⽂件”路径：⽂件或者⽂件夹   File的常⻅⽅法 绝对路径与相对路径 读/写⽂件 NIO （Java 7+）  New IO 新的IO Non-blocking IO ⾮阻塞IO   NIO的Path - 就是旧版本的File  IO太慢了，怎么办？  BufferedReader/Writer  换⾏符的故事   BufferedReader - ⼀次性读取好多东⻄到缓冲区⾥ BufferedWriter - ⼀次性写好多东⻄到缓冲区⾥ 在内存中创建好，⼀次写⼊  烦⼈的IOException  Java的异常体系简介  在return语句之外，为⽅法提供另外⼀种出⼝ IOException通常代表“预期之内的异常”   万能解决⽅案  Java中的NIO  Path与File 最常⽤的Files类 NIO简介  不需要重复发明轮⼦  需要任何IO的功能，尽管搜索，肯定有⼈把轮⼦造好了。  FileUtils IOUtils    try/catch/finally  如果没有try，异常将击穿所有的栈帧 catch可以将⼀个异常抓住 finally执⾏清理⼯作 JDK7+：try-with-resources  Java的异常体系  Throwable - 可以被抛出的东⻄  Exception - checked execption（受检异常）  RuntimeException （运⾏时异常）   Error （错误）    实战：将爬⾍数据保存⾄⽂件  CSV简介 读取/写⼊结构化数据  </description>
    </item>
    
    <item>
      <title>24 中级 - Java Web：HTTP基础课堂笔记</title>
      <link>http://mcdul1996.github.io/posts/24/</link>
      <pubDate>Tue, 09 Jun 2020 10:17:44 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/24/</guid>
      <description>HTTP⼊⻔与详解 HTTP method 最重要的几种方法：
 GET:请求指定的页面信息，并返回实体主体。 POST：向指定资源提交数据进行处理请求(例如提交表单或者上传文件)，数据被包含在请求中，POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT：从客户端服务器传送的数据取代指定的文档的内容。 DELETE：请求服务器删除指定的页面。 &amp;hellip;很多其他方法  关于如何反爬虫  Status 401/403 在返回的数据中投毒(故意返回错误的数据阴它)  HTTP status  1xx: 信息，服务器收到请求，需要请求者继续执行操作 2xx: 成功，操作被成功接收并处理 3xx: 重定向，需要进一步的操作以完成请求 4xx：客户端错误，请求包含语法错误或无法完成请求 5xx：服务器错误，服务器在处理请求的过程中发生了错误 Joke: 6xx ? http根本没有6xx,出了骂你们的后端，想不到其他解决方案 具体的可以看http.cat  HTTP请求header  重要的header  Host: 代表我要请求计算机网络上的哪台主机。 Accept*：浏览器(前端)告诉服务器(后端)：“我想要接收什么类型的数据”  Accept-Encoding:我想要的编码 Accept-language:我想要的语言   Cookie User-Agent： 代表了一个用户代理 Referer(正确的拼写referrer):浏览器用来告诉后端服务器当前的页面是从哪里跳转过来的  使用地方：防盗链系统      HTTP响应header  这个响应是根据请求来的， 重要的header  Content-type:告诉浏览器(前端)，当前的这个HTTP响应是什么类型的，应该如何被解析 典型的类型有：  text/plain :纯文本 image xml   Content-type与Accept这两个header可以让你的http请求更加的灵活： Http通道上跑的只是字节流，但是通过Content-type，服务器就能告诉浏览器，当前的这个字节流是什么类型的数据！浏览器就会按照这个类型来解析这个数据  application/zip(下载数据) image/jpeg(图片)   Set-Cookie    HTTP body  HTTP request body  表单 k-v对   HTTP response body：  当浏览器发送一个下载请求，服务器响应200 ok Content-type:zip&amp;hellip;后面跟的body就是要下载的内容，浏览器看到这个响应类型是ZIP的时候就懂了，直接将后面跟着的Body给下载下来</description>
    </item>
    
    <item>
      <title>23-java web: web前后端架构分析实战</title>
      <link>http://mcdul1996.github.io/posts/%E7%AC%AC23%E8%8A%82%E8%AF%BE%E7%9A%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 07 Jun 2020 07:55:48 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E7%AC%AC23%E8%8A%82%E8%AF%BE%E7%9A%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</guid>
      <description>Web前后端基础架构原理 计算机⽹络是如何⼯作的(数据是如何发送和接收的)  在打开⽹⻚的时候发⽣了什么    计算机网络：
 世界上很多台主机彼此之间用网络连接起来，每个主机都有个IP地址    IP地址(Internet Protocol Address:网络协议)：
 在IPV4的世界里是32位，4个Byte(无符号，所以每个Byte最大不超过255)，用点连接起来的IP地址 每个地址都可以准确定位到一台主机 IPv6可以为地球上的每一粒沙子提供一个地址，可以解决IPV4带来的IP地址短缺问题    域名与DNS(域名解析服务器)
  在网页上输入豆瓣网址的时候，按下回车 如果计算机不知道淘宝的主机在哪，它就会向DNS请求查询douban.com,DNS会返回一个地址154.8.131.172，按照这个地址，你就能够去跟豆瓣的主机通信了
  如果本地hosts恰好保存了从douban.com-&amp;gt;154.8.131.172的映射 我们就不需要查找DNS了，节省时间
    端⼝：
  一台计算机有很多很多对外的端口，你可以指定与其中一个进行通信
  HTTPS协议的默认端⼝是443，HTTP协议的默认端⼝是80
  端口指定了你通信的这个主机上的一个归属地
    TCP协议(Transmission Control Protocol：传输控制协议)
 TCP是基于流的协议,在⽹络上传输的只是字节流，这点非常关键！请记住！ TCP是一条双向的数据高速公路：向你想要访问的服务器所指定的端口开辟了一条双向双车道的一个数据高速公路 定义了字节流在网络上如何发送和接收    浏览器是如何⼯作的(数据是如何被浏览器处理的)   HTTP协议(HyperText Transfer Protocol:超文本传输协议)
 通过浏览器给豆瓣发送一个HTTP请求 请求报文的组成内容:  请求行: 请求方法 + URL + HTTP/版本号 请求头 空行 请求体   豆瓣服务器处理浏览器请求，将处理结果返回给浏览器(响应)：  响应头(Response Headers):HTTP/版本号 + 返回码 + 返回码描述  HTTP/1.</description>
    </item>
    
    <item>
      <title>关于我在Collection体系中学到的知识</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8collection%E4%BD%93%E7%B3%BB%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Sat, 06 Jun 2020 16:15:12 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%9C%A8collection%E4%BD%93%E7%B3%BB%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86/</guid>
      <description>Collection体系的常用类及其背后的数据结构  List    ArrayList： 背后是一个动态数组，有序插入元素，可以根据下标取得对应元素，检索元素为线性查找，效率较低。当容量不足时会自动扩容，每次新建一个新的List，大小为原来的1.5倍，再将所有元素拷贝到新的List中去。
  LinkedList： 背后是一个链表结构，有序插入元素，可以根据下标取得对应元素， 检索时从头部或者尾部不断向下标靠拢，所以头部和尾部的查找效率高，中间低。
   Set   HashSet： 计算出元素的哈希值，哈希值相同的元素放在同一个哈希桶里，每个哈希桶里维护一个链表。插入的元素是无序的且不允许出现重复元素，查找效率高。但当发生哈希碰撞时，整个结构退化为链表会导致性能急剧下降。 LinkedHashSet： 不同于HashSet，前面的数据结构为链表，所以是有序的，其他几乎一样。 TreeSet： 前面的数据结构为二叉树，可以对插入的元素进行排序。检索快，时间复杂度降为对数级。   Map   HashMap： 实质上和HashSet一样，不过可以存储键（Key）到值（Value）的映射。JDK1.8之后当链表节点大于7时会裂变为红黑树。 TreeMap： 可以排序的HashMap。  ArrayList源码分析    ArrayList是最常用的一种集合类型  public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable 表示ArrayList继承自AbstractList,实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。 说明它具备以下特点：
 浅拷贝 序列化   常量 private static final int DEFAULT_CAPACITY = 10;  DEFAULT_CAPACITY 表示默认的容量是10个元素   成员变量 transient Object[] elementData; private int size;  elementData为实际存储元素的数组，这里可以看到ArrayList的底层实际是一个数组。因此它具有数组的特点，随机读写快，插入删除慢。 transient关键字说明底层数组不能被序列化。   构造函数 public ArrayList() { this.</description>
    </item>
    
    <item>
      <title>游戏题材</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%A5%E5%90%8E%E6%83%B3%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A2%98%E6%9D%90.md/%E6%B8%B8%E6%88%8F%E9%A2%98%E6%9D%90/</link>
      <pubDate>Tue, 02 Jun 2020 17:24:19 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%A5%E5%90%8E%E6%83%B3%E8%A6%81%E5%81%9A%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A2%98%E6%9D%90.md/%E6%B8%B8%E6%88%8F%E9%A2%98%E6%9D%90/</guid>
      <description>人生有好多细节,决定了你的成长速度</description>
    </item>
    
    <item>
      <title>关于我对maven和java包管理的理解</title>
      <link>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9maven%E5%92%8Cjava%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sat, 30 May 2020 11:45:07 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%85%B3%E4%BA%8E%E6%88%91%E5%AF%B9maven%E5%92%8Cjava%E5%8C%85%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>java的包管理 1. 什么是包  就是一个包含许多类的一个压缩包 这个包的作用是： 当JVM要找一个类的时候，它就会从classpath(类路径)里挨个一个个包里寻找这个类  2. 什么是包管理  包管理的本质就是告诉JVM如何找到所需要的第三方类库 并且可以解决其中的冲突问题(classpath里的某些包都含有同名不同版本的类，由于基本规则选择的那个优先的类里面的代码并不是你想要的，可能还存在BUG)  3. Maven是什么  Maven是划时代的包管理工具(必须强调Maven远远不止是包管理工具) Convention over configuration(约定优于配置) Maven有两个仓库 Maven的中央仓库：在远端的服务器上 包含了世界上所有的包(按照一定的约定存储包) Maven的本地仓库：默认位于~/.m2 你不可能每次编译的时候都把世界上所有的包下载下来，你可能想要在断网的时候进行编译 当你需要用包的时候，maven会帮你自动的从中央仓库下载，下载的第三方包放在这里进行缓存  4. Maven的包  按照约定为所有的包编号，⽅便检索 groupId/artifactId/version 扩展：语义化版本 SNAPSHOT快照版本： 因为maven有一个约定：当你这个包发布的时候，不允许你再去修改它，但是你在开发过程中需要频繁的修改它 传递性依赖：虽然你只下载了一个包，但maven会根据pom将这个包的完整的依赖树都下载下来 传递性依赖的⾃动管理 原则：绝对不允许最终的classpath出现同名不同版本的jar包 依赖冲突的解决原则：最近的胜出(但是很可能这个胜出的包里面的类的代码并不是你想要的，这个时候我们就需要根据自己的需要利用Maven使自己想要的包胜出) 方法1：既然是谁离得近谁赢，那就直接在我的项目里直接依赖我想要的版本的jar包 方法2：直接使用 排除那个胜出的版本的包  </description>
    </item>
    
    <item>
      <title>如何使用 Hugo 搭建个人博客</title>
      <link>http://mcdul1996.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Thu, 28 May 2020 16:03:50 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</guid>
      <description>1.下载 Hugo
进入Hugo下载 在 Assets 中下载合适的版本， 例如：hugo_0.58.3_Windows-64bit.zip （找各自系统对应的版本下载） 解压到自定义文件夹（我的是解压到 D:\Software\hugo） 2.配置环境变量
我的电脑—-&amp;gt;属性—-&amp;gt;高级系统设置—-&amp;gt;环境变量—-&amp;gt;系统变量—-&amp;gt; Path—-&amp;gt;新增 D:\Hugo 路径（根据 hugo.exe 的位置自行更换路径） 重启终端，运行hugo version 查看版本 3.利用 hugo 生成自己的博客 site
推荐找个安全的目录打开命令行,我的目录是 D:\Software\McDul 复制执行下条命令: hugo new site [username].github.io-creator 会生成一个文件夹[username].github.io-creator 接着进入这个文件目录： cd [username].github.io-creator 创建 git 本地仓库： git init 下载 Ananke 博客主题： git submodule add https://github.com/budparr/gohugo-theme-ananke.gitthemes/ananke  在 config.toml 文件中将主题改成 Ananke： echo &amp;#39;theme=Ananke&amp;#39; &amp;gt;&amp;gt; config.toml 用 hugo 搭建了自己的博客已完成 4.开始建立第一篇博客
新建文章： hugo new posts/第二篇博客.md 运行 code posts/第二篇博客.md 对文件进行编辑， 注意不要把文件原本的内容给删了，直接在后面另起一行写新内容， 修改好之后将 draft 后的 true 改成 false 表示已经不是草稿模式， 保存。 5.</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://mcdul1996.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Tue, 26 May 2020 16:38:47 +0800</pubDate>
      
      <guid>http://mcdul1996.github.io/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>大家好 我的博客开通了，希望我能写出好文章给大家看。</description>
    </item>
    
  </channel>
</rss>